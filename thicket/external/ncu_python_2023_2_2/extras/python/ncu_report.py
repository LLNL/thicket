# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


# Copyright (c) 2020-2021, NVIDIA CORPORATION. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#  * Neither the name of NVIDIA CORPORATION nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ncu_report
else:
    import _ncu_report

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _ncu_report.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        r"""
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _ncu_report.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        r"""
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _ncu_report.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        r"""
        distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _ncu_report.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        r"""
        equal(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _ncu_report.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _ncu_report.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _ncu_report.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _ncu_report.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _ncu_report.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""
        advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _ncu_report.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        r"""
        __eq__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _ncu_report.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        r"""
        __ne__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _ncu_report.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""
        __iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _ncu_report.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""
        __isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _ncu_report.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""
        __add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _ncu_report.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _ncu_report.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _ncu_report:
_ncu_report.SwigPyIterator_swigregister(SwigPyIterator)

class map_string_string(object):
    r"""Proxy of C++ std::map< std::string,std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(map_string_string self) -> SwigPyIterator"""
        return _ncu_report.map_string_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(map_string_string self) -> bool"""
        return _ncu_report.map_string_string___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(map_string_string self) -> bool"""
        return _ncu_report.map_string_string___bool__(self)

    def __len__(self) -> "std::map< std::string,std::string >::size_type":
        r"""__len__(map_string_string self) -> std::map< std::string,std::string >::size_type"""
        return _ncu_report.map_string_string___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::mapped_type const &":
        r"""
        __getitem__(map_string_string self, std::map< std::string,std::string >::key_type const & key) -> std::map< std::string,std::string >::mapped_type const &

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _ncu_report.map_string_string___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "void":
        r"""
        __delitem__(map_string_string self, std::map< std::string,std::string >::key_type const & key)

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _ncu_report.map_string_string___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        r"""
        has_key(map_string_string self, std::map< std::string,std::string >::key_type const & key) -> bool

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _ncu_report.map_string_string_has_key(self, key)

    def keys(self) -> "PyObject *":
        r"""keys(map_string_string self) -> PyObject *"""
        return _ncu_report.map_string_string_keys(self)

    def values(self) -> "PyObject *":
        r"""values(map_string_string self) -> PyObject *"""
        return _ncu_report.map_string_string_values(self)

    def items(self) -> "PyObject *":
        r"""items(map_string_string self) -> PyObject *"""
        return _ncu_report.map_string_string_items(self)

    def __contains__(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        r"""
        __contains__(map_string_string self, std::map< std::string,std::string >::key_type const & key) -> bool

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _ncu_report.map_string_string___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        r"""key_iterator(map_string_string self) -> SwigPyIterator"""
        return _ncu_report.map_string_string_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        r"""value_iterator(map_string_string self) -> SwigPyIterator"""
        return _ncu_report.map_string_string_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(map_string_string self, std::map< std::string,std::string >::key_type const & key)

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        __setitem__(map_string_string self, std::map< std::string,std::string >::key_type const & key, std::map< std::string,std::string >::mapped_type const & x)

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &
        x: std::map< std::string,std::string >::mapped_type const &

        """
        return _ncu_report.map_string_string___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        r"""asdict(map_string_string self) -> PyObject *"""
        return _ncu_report.map_string_string_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(map_string_string self, std::less< std::string > const & other) -> map_string_string

        Parameters
        ----------
        other: std::less< std::string > const &

        __init__(map_string_string self) -> map_string_string
        __init__(map_string_string self, map_string_string other) -> map_string_string

        Parameters
        ----------
        other: std::map< std::string,std::string > const &

        """
        _ncu_report.map_string_string_swiginit(self, _ncu_report.new_map_string_string(*args))

    def empty(self) -> "bool":
        r"""empty(map_string_string self) -> bool"""
        return _ncu_report.map_string_string_empty(self)

    def size(self) -> "std::map< std::string,std::string >::size_type":
        r"""size(map_string_string self) -> std::map< std::string,std::string >::size_type"""
        return _ncu_report.map_string_string_size(self)

    def swap(self, v: "map_string_string") -> "void":
        r"""
        swap(map_string_string self, map_string_string v)

        Parameters
        ----------
        v: std::map< std::string,std::string > &

        """
        return _ncu_report.map_string_string_swap(self, v)

    def begin(self) -> "std::map< std::string,std::string >::iterator":
        r"""begin(map_string_string self) -> std::map< std::string,std::string >::iterator"""
        return _ncu_report.map_string_string_begin(self)

    def end(self) -> "std::map< std::string,std::string >::iterator":
        r"""end(map_string_string self) -> std::map< std::string,std::string >::iterator"""
        return _ncu_report.map_string_string_end(self)

    def rbegin(self) -> "std::map< std::string,std::string >::reverse_iterator":
        r"""rbegin(map_string_string self) -> std::map< std::string,std::string >::reverse_iterator"""
        return _ncu_report.map_string_string_rbegin(self)

    def rend(self) -> "std::map< std::string,std::string >::reverse_iterator":
        r"""rend(map_string_string self) -> std::map< std::string,std::string >::reverse_iterator"""
        return _ncu_report.map_string_string_rend(self)

    def clear(self) -> "void":
        r"""clear(map_string_string self)"""
        return _ncu_report.map_string_string_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::string >::allocator_type":
        r"""get_allocator(map_string_string self) -> std::map< std::string,std::string >::allocator_type"""
        return _ncu_report.map_string_string_get_allocator(self)

    def count(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::size_type":
        r"""
        count(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::size_type

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _ncu_report.map_string_string_count(self, x)

    def erase(self, *args) -> "void":
        r"""
        erase(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::size_type

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        erase(map_string_string self, std::map< std::string,std::string >::iterator position)

        Parameters
        ----------
        position: std::map< std::string,std::string >::iterator

        erase(map_string_string self, std::map< std::string,std::string >::iterator first, std::map< std::string,std::string >::iterator last)

        Parameters
        ----------
        first: std::map< std::string,std::string >::iterator
        last: std::map< std::string,std::string >::iterator

        """
        return _ncu_report.map_string_string_erase(self, *args)

    def find(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        r"""
        find(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::iterator

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _ncu_report.map_string_string_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        r"""
        lower_bound(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::iterator

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _ncu_report.map_string_string_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        r"""
        upper_bound(map_string_string self, std::map< std::string,std::string >::key_type const & x) -> std::map< std::string,std::string >::iterator

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _ncu_report.map_string_string_upper_bound(self, x)
    __swig_destroy__ = _ncu_report.delete_map_string_string

# Register map_string_string in _ncu_report:
_ncu_report.map_string_string_swigregister(map_string_string)

class set_string(object):
    r"""Proxy of C++ std::set< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(set_string self) -> SwigPyIterator"""
        return _ncu_report.set_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(set_string self) -> bool"""
        return _ncu_report.set_string___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(set_string self) -> bool"""
        return _ncu_report.set_string___bool__(self)

    def __len__(self) -> "std::set< std::string >::size_type":
        r"""__len__(set_string self) -> std::set< std::string >::size_type"""
        return _ncu_report.set_string___len__(self)

    def append(self, x: "std::set< std::string >::value_type") -> "void":
        r"""
        append(set_string self, std::set< std::string >::value_type x)

        Parameters
        ----------
        x: std::set< std::string >::value_type

        """
        return _ncu_report.set_string_append(self, x)

    def __contains__(self, x: "std::set< std::string >::value_type") -> "bool":
        r"""
        __contains__(set_string self, std::set< std::string >::value_type x) -> bool

        Parameters
        ----------
        x: std::set< std::string >::value_type

        """
        return _ncu_report.set_string___contains__(self, x)

    def __getitem__(self, i: "std::set< std::string >::difference_type") -> "std::set< std::string >::value_type":
        r"""
        __getitem__(set_string self, std::set< std::string >::difference_type i) -> std::set< std::string >::value_type

        Parameters
        ----------
        i: std::set< std::string >::difference_type

        """
        return _ncu_report.set_string___getitem__(self, i)

    def add(self, x: "std::set< std::string >::value_type") -> "void":
        r"""
        add(set_string self, std::set< std::string >::value_type x)

        Parameters
        ----------
        x: std::set< std::string >::value_type

        """
        return _ncu_report.set_string_add(self, x)

    def discard(self, x: "std::set< std::string >::value_type") -> "void":
        r"""
        discard(set_string self, std::set< std::string >::value_type x)

        Parameters
        ----------
        x: std::set< std::string >::value_type

        """
        return _ncu_report.set_string_discard(self, x)

    def __init__(self, *args):
        r"""
        __init__(set_string self, std::less< std::string > const & other) -> set_string

        Parameters
        ----------
        other: std::less< std::string > const &

        __init__(set_string self) -> set_string
        __init__(set_string self, set_string other) -> set_string

        Parameters
        ----------
        other: std::set< std::string > const &

        """
        _ncu_report.set_string_swiginit(self, _ncu_report.new_set_string(*args))

    def empty(self) -> "bool":
        r"""empty(set_string self) -> bool"""
        return _ncu_report.set_string_empty(self)

    def size(self) -> "std::set< std::string >::size_type":
        r"""size(set_string self) -> std::set< std::string >::size_type"""
        return _ncu_report.set_string_size(self)

    def clear(self) -> "void":
        r"""clear(set_string self)"""
        return _ncu_report.set_string_clear(self)

    def swap(self, v: "set_string") -> "void":
        r"""
        swap(set_string self, set_string v)

        Parameters
        ----------
        v: std::set< std::string > &

        """
        return _ncu_report.set_string_swap(self, v)

    def count(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::size_type":
        r"""
        count(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::size_type

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _ncu_report.set_string_count(self, x)

    def begin(self) -> "std::set< std::string >::iterator":
        r"""begin(set_string self) -> std::set< std::string >::iterator"""
        return _ncu_report.set_string_begin(self)

    def end(self) -> "std::set< std::string >::iterator":
        r"""end(set_string self) -> std::set< std::string >::iterator"""
        return _ncu_report.set_string_end(self)

    def rbegin(self) -> "std::set< std::string >::reverse_iterator":
        r"""rbegin(set_string self) -> std::set< std::string >::reverse_iterator"""
        return _ncu_report.set_string_rbegin(self)

    def rend(self) -> "std::set< std::string >::reverse_iterator":
        r"""rend(set_string self) -> std::set< std::string >::reverse_iterator"""
        return _ncu_report.set_string_rend(self)

    def erase(self, *args) -> "void":
        r"""
        erase(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::size_type

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        erase(set_string self, std::set< std::string >::iterator pos)

        Parameters
        ----------
        pos: std::set< std::string >::iterator

        erase(set_string self, std::set< std::string >::iterator first, std::set< std::string >::iterator last)

        Parameters
        ----------
        first: std::set< std::string >::iterator
        last: std::set< std::string >::iterator

        """
        return _ncu_report.set_string_erase(self, *args)

    def find(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::iterator":
        r"""
        find(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::iterator

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _ncu_report.set_string_find(self, x)

    def lower_bound(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::iterator":
        r"""
        lower_bound(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::iterator

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _ncu_report.set_string_lower_bound(self, x)

    def upper_bound(self, x: "std::set< std::string >::key_type const &") -> "std::set< std::string >::iterator":
        r"""
        upper_bound(set_string self, std::set< std::string >::key_type const & x) -> std::set< std::string >::iterator

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _ncu_report.set_string_upper_bound(self, x)

    def equal_range(self, x: "std::set< std::string >::key_type const &") -> "std::pair< std::set< std::string >::iterator,std::set< std::string >::iterator >":
        r"""
        equal_range(set_string self, std::set< std::string >::key_type const & x) -> std::pair< std::set< std::string >::iterator,std::set< std::string >::iterator >

        Parameters
        ----------
        x: std::set< std::string >::key_type const &

        """
        return _ncu_report.set_string_equal_range(self, x)

    def insert(self, __x: "std::set< std::string >::value_type const &") -> "std::pair< std::set< std::string >::iterator,bool >":
        r"""
        insert(set_string self, std::set< std::string >::value_type const & __x) -> std::pair< std::set< std::string >::iterator,bool >

        Parameters
        ----------
        __x: std::set< std::string >::value_type const &

        """
        return _ncu_report.set_string_insert(self, __x)
    __swig_destroy__ = _ncu_report.delete_set_string

# Register set_string in _ncu_report:
_ncu_report.set_string_swigregister(set_string)

class set_ull(object):
    r"""Proxy of C++ std::set< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(set_ull self) -> SwigPyIterator"""
        return _ncu_report.set_ull_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(set_ull self) -> bool"""
        return _ncu_report.set_ull___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(set_ull self) -> bool"""
        return _ncu_report.set_ull___bool__(self)

    def __len__(self) -> "std::set< unsigned long long >::size_type":
        r"""__len__(set_ull self) -> std::set< unsigned long long >::size_type"""
        return _ncu_report.set_ull___len__(self)

    def append(self, x: "std::set< unsigned long long >::value_type") -> "void":
        r"""
        append(set_ull self, std::set< unsigned long long >::value_type x)

        Parameters
        ----------
        x: std::set< unsigned long long >::value_type

        """
        return _ncu_report.set_ull_append(self, x)

    def __contains__(self, x: "std::set< unsigned long long >::value_type") -> "bool":
        r"""
        __contains__(set_ull self, std::set< unsigned long long >::value_type x) -> bool

        Parameters
        ----------
        x: std::set< unsigned long long >::value_type

        """
        return _ncu_report.set_ull___contains__(self, x)

    def __getitem__(self, i: "std::set< unsigned long long >::difference_type") -> "std::set< unsigned long long >::value_type":
        r"""
        __getitem__(set_ull self, std::set< unsigned long long >::difference_type i) -> std::set< unsigned long long >::value_type

        Parameters
        ----------
        i: std::set< unsigned long long >::difference_type

        """
        return _ncu_report.set_ull___getitem__(self, i)

    def add(self, x: "std::set< unsigned long long >::value_type") -> "void":
        r"""
        add(set_ull self, std::set< unsigned long long >::value_type x)

        Parameters
        ----------
        x: std::set< unsigned long long >::value_type

        """
        return _ncu_report.set_ull_add(self, x)

    def discard(self, x: "std::set< unsigned long long >::value_type") -> "void":
        r"""
        discard(set_ull self, std::set< unsigned long long >::value_type x)

        Parameters
        ----------
        x: std::set< unsigned long long >::value_type

        """
        return _ncu_report.set_ull_discard(self, x)

    def __init__(self, *args):
        r"""
        __init__(set_ull self, std::less< unsigned long long > const & other) -> set_ull

        Parameters
        ----------
        other: std::less< unsigned long long > const &

        __init__(set_ull self) -> set_ull
        __init__(set_ull self, set_ull other) -> set_ull

        Parameters
        ----------
        other: std::set< unsigned long long > const &

        """
        _ncu_report.set_ull_swiginit(self, _ncu_report.new_set_ull(*args))

    def empty(self) -> "bool":
        r"""empty(set_ull self) -> bool"""
        return _ncu_report.set_ull_empty(self)

    def size(self) -> "std::set< unsigned long long >::size_type":
        r"""size(set_ull self) -> std::set< unsigned long long >::size_type"""
        return _ncu_report.set_ull_size(self)

    def clear(self) -> "void":
        r"""clear(set_ull self)"""
        return _ncu_report.set_ull_clear(self)

    def swap(self, v: "set_ull") -> "void":
        r"""
        swap(set_ull self, set_ull v)

        Parameters
        ----------
        v: std::set< unsigned long long > &

        """
        return _ncu_report.set_ull_swap(self, v)

    def count(self, x: "std::set< unsigned long long >::key_type const &") -> "std::set< unsigned long long >::size_type":
        r"""
        count(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::size_type

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _ncu_report.set_ull_count(self, x)

    def begin(self) -> "std::set< unsigned long long >::iterator":
        r"""begin(set_ull self) -> std::set< unsigned long long >::iterator"""
        return _ncu_report.set_ull_begin(self)

    def end(self) -> "std::set< unsigned long long >::iterator":
        r"""end(set_ull self) -> std::set< unsigned long long >::iterator"""
        return _ncu_report.set_ull_end(self)

    def rbegin(self) -> "std::set< unsigned long long >::reverse_iterator":
        r"""rbegin(set_ull self) -> std::set< unsigned long long >::reverse_iterator"""
        return _ncu_report.set_ull_rbegin(self)

    def rend(self) -> "std::set< unsigned long long >::reverse_iterator":
        r"""rend(set_ull self) -> std::set< unsigned long long >::reverse_iterator"""
        return _ncu_report.set_ull_rend(self)

    def erase(self, *args) -> "void":
        r"""
        erase(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::size_type

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        erase(set_ull self, std::set< unsigned long long >::iterator pos)

        Parameters
        ----------
        pos: std::set< unsigned long long >::iterator

        erase(set_ull self, std::set< unsigned long long >::iterator first, std::set< unsigned long long >::iterator last)

        Parameters
        ----------
        first: std::set< unsigned long long >::iterator
        last: std::set< unsigned long long >::iterator

        """
        return _ncu_report.set_ull_erase(self, *args)

    def find(self, x: "std::set< unsigned long long >::key_type const &") -> "std::set< unsigned long long >::iterator":
        r"""
        find(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::iterator

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _ncu_report.set_ull_find(self, x)

    def lower_bound(self, x: "std::set< unsigned long long >::key_type const &") -> "std::set< unsigned long long >::iterator":
        r"""
        lower_bound(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::iterator

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _ncu_report.set_ull_lower_bound(self, x)

    def upper_bound(self, x: "std::set< unsigned long long >::key_type const &") -> "std::set< unsigned long long >::iterator":
        r"""
        upper_bound(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::set< unsigned long long >::iterator

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _ncu_report.set_ull_upper_bound(self, x)

    def equal_range(self, x: "std::set< unsigned long long >::key_type const &") -> "std::pair< std::set< unsigned long long >::iterator,std::set< unsigned long long >::iterator >":
        r"""
        equal_range(set_ull self, std::set< unsigned long long >::key_type const & x) -> std::pair< std::set< unsigned long long >::iterator,std::set< unsigned long long >::iterator >

        Parameters
        ----------
        x: std::set< unsigned long long >::key_type const &

        """
        return _ncu_report.set_ull_equal_range(self, x)

    def insert(self, __x: "std::set< unsigned long long >::value_type const &") -> "std::pair< std::set< unsigned long long >::iterator,bool >":
        r"""
        insert(set_ull self, std::set< unsigned long long >::value_type const & __x) -> std::pair< std::set< unsigned long long >::iterator,bool >

        Parameters
        ----------
        __x: std::set< unsigned long long >::value_type const &

        """
        return _ncu_report.set_ull_insert(self, __x)
    __swig_destroy__ = _ncu_report.delete_set_ull

# Register set_ull in _ncu_report:
_ncu_report.set_ull_swigregister(set_ull)

class vector_string(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(vector_string self) -> SwigPyIterator"""
        return _ncu_report.vector_string_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(vector_string self) -> bool"""
        return _ncu_report.vector_string___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(vector_string self) -> bool"""
        return _ncu_report.vector_string___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        r"""__len__(vector_string self) -> std::vector< std::string >::size_type"""
        return _ncu_report.vector_string___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        r"""
        __getslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> vector_string

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _ncu_report.vector_string___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        __setslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, vector_string v)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type
        v: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _ncu_report.vector_string___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        r"""
        __delslice__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        j: std::vector< std::string >::difference_type

        """
        return _ncu_report.vector_string___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(vector_string self, std::vector< std::string >::difference_type i)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        __delitem__(vector_string self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _ncu_report.vector_string___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        r"""
        __getitem__(vector_string self, PySliceObject * slice) -> vector_string

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(vector_string self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &

        Parameters
        ----------
        i: std::vector< std::string >::difference_type

        """
        return _ncu_report.vector_string___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(vector_string self, PySliceObject * slice, vector_string v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< std::string,std::allocator< std::string > > const &

        __setitem__(vector_string self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(vector_string self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        i: std::vector< std::string >::difference_type
        x: std::vector< std::string >::value_type const &

        """
        return _ncu_report.vector_string___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        r"""pop(vector_string self) -> std::vector< std::string >::value_type"""
        return _ncu_report.vector_string_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        r"""
        append(vector_string self, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _ncu_report.vector_string_append(self, x)

    def empty(self) -> "bool":
        r"""empty(vector_string self) -> bool"""
        return _ncu_report.vector_string_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        r"""size(vector_string self) -> std::vector< std::string >::size_type"""
        return _ncu_report.vector_string_size(self)

    def swap(self, v: "vector_string") -> "void":
        r"""
        swap(vector_string self, vector_string v)

        Parameters
        ----------
        v: std::vector< std::string > &

        """
        return _ncu_report.vector_string_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        r"""begin(vector_string self) -> std::vector< std::string >::iterator"""
        return _ncu_report.vector_string_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        r"""end(vector_string self) -> std::vector< std::string >::iterator"""
        return _ncu_report.vector_string_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        r"""rbegin(vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _ncu_report.vector_string_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        r"""rend(vector_string self) -> std::vector< std::string >::reverse_iterator"""
        return _ncu_report.vector_string_rend(self)

    def clear(self) -> "void":
        r"""clear(vector_string self)"""
        return _ncu_report.vector_string_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        r"""get_allocator(vector_string self) -> std::vector< std::string >::allocator_type"""
        return _ncu_report.vector_string_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(vector_string self)"""
        return _ncu_report.vector_string_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        r"""
        erase(vector_string self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator

        erase(vector_string self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator

        Parameters
        ----------
        first: std::vector< std::string >::iterator
        last: std::vector< std::string >::iterator

        """
        return _ncu_report.vector_string_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_string self) -> vector_string
        __init__(vector_string self, vector_string other) -> vector_string

        Parameters
        ----------
        other: std::vector< std::string > const &

        __init__(vector_string self, std::vector< std::string >::size_type size) -> vector_string

        Parameters
        ----------
        size: std::vector< std::string >::size_type

        __init__(vector_string self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> vector_string

        Parameters
        ----------
        size: std::vector< std::string >::size_type
        value: std::vector< std::string >::value_type const &

        """
        _ncu_report.vector_string_swiginit(self, _ncu_report.new_vector_string(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        r"""
        push_back(vector_string self, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        x: std::vector< std::string >::value_type const &

        """
        return _ncu_report.vector_string_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        r"""front(vector_string self) -> std::vector< std::string >::value_type const &"""
        return _ncu_report.vector_string_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        r"""back(vector_string self) -> std::vector< std::string >::value_type const &"""
        return _ncu_report.vector_string_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        r"""
        assign(vector_string self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _ncu_report.vector_string_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(vector_string self, std::vector< std::string >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type

        resize(vector_string self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _ncu_report.vector_string_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        x: std::vector< std::string >::value_type const &

        insert(vector_string self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< std::string >::iterator
        n: std::vector< std::string >::size_type
        x: std::vector< std::string >::value_type const &

        """
        return _ncu_report.vector_string_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        r"""
        reserve(vector_string self, std::vector< std::string >::size_type n)

        Parameters
        ----------
        n: std::vector< std::string >::size_type

        """
        return _ncu_report.vector_string_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        r"""capacity(vector_string self) -> std::vector< std::string >::size_type"""
        return _ncu_report.vector_string_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_string

# Register vector_string in _ncu_report:
_ncu_report.vector_string_swigregister(vector_string)

class vector_ull(object):
    r"""Proxy of C++ std::vector< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(vector_ull self) -> SwigPyIterator"""
        return _ncu_report.vector_ull_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(vector_ull self) -> bool"""
        return _ncu_report.vector_ull___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(vector_ull self) -> bool"""
        return _ncu_report.vector_ull___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        r"""__len__(vector_ull self) -> std::vector< unsigned long long >::size_type"""
        return _ncu_report.vector_ull___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        r"""
        __getslice__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j) -> vector_ull

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        """
        return _ncu_report.vector_ull___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        __setslice__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j, vector_ull v)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type
        v: std::vector< unsigned long long,std::allocator< unsigned long long > > const &

        """
        return _ncu_report.vector_ull___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "void":
        r"""
        __delslice__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::difference_type j)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        """
        return _ncu_report.vector_ull___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(vector_ull self, std::vector< unsigned long long >::difference_type i)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type

        __delitem__(vector_ull self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        """
        return _ncu_report.vector_ull___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        r"""
        __getitem__(vector_ull self, PySliceObject * slice) -> vector_ull

        Parameters
        ----------
        slice: PySliceObject *

        __getitem__(vector_ull self, std::vector< unsigned long long >::difference_type i) -> std::vector< unsigned long long >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type

        """
        return _ncu_report.vector_ull___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(vector_ull self, PySliceObject * slice, vector_ull v)

        Parameters
        ----------
        slice: PySliceObject *
        v: std::vector< unsigned long long,std::allocator< unsigned long long > > const &

        __setitem__(vector_ull self, PySliceObject * slice)

        Parameters
        ----------
        slice: PySliceObject *

        __setitem__(vector_ull self, std::vector< unsigned long long >::difference_type i, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _ncu_report.vector_ull___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        r"""pop(vector_ull self) -> std::vector< unsigned long long >::value_type"""
        return _ncu_report.vector_ull_pop(self)

    def append(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""
        append(vector_ull self, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned long long >::value_type const &

        """
        return _ncu_report.vector_ull_append(self, x)

    def empty(self) -> "bool":
        r"""empty(vector_ull self) -> bool"""
        return _ncu_report.vector_ull_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        r"""size(vector_ull self) -> std::vector< unsigned long long >::size_type"""
        return _ncu_report.vector_ull_size(self)

    def swap(self, v: "vector_ull") -> "void":
        r"""
        swap(vector_ull self, vector_ull v)

        Parameters
        ----------
        v: std::vector< unsigned long long > &

        """
        return _ncu_report.vector_ull_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        r"""begin(vector_ull self) -> std::vector< unsigned long long >::iterator"""
        return _ncu_report.vector_ull_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        r"""end(vector_ull self) -> std::vector< unsigned long long >::iterator"""
        return _ncu_report.vector_ull_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        r"""rbegin(vector_ull self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _ncu_report.vector_ull_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        r"""rend(vector_ull self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _ncu_report.vector_ull_rend(self)

    def clear(self) -> "void":
        r"""clear(vector_ull self)"""
        return _ncu_report.vector_ull_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        r"""get_allocator(vector_ull self) -> std::vector< unsigned long long >::allocator_type"""
        return _ncu_report.vector_ull_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(vector_ull self)"""
        return _ncu_report.vector_ull_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        r"""
        erase(vector_ull self, std::vector< unsigned long long >::iterator pos) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator

        erase(vector_ull self, std::vector< unsigned long long >::iterator first, std::vector< unsigned long long >::iterator last) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        first: std::vector< unsigned long long >::iterator
        last: std::vector< unsigned long long >::iterator

        """
        return _ncu_report.vector_ull_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(vector_ull self) -> vector_ull
        __init__(vector_ull self, vector_ull other) -> vector_ull

        Parameters
        ----------
        other: std::vector< unsigned long long > const &

        __init__(vector_ull self, std::vector< unsigned long long >::size_type size) -> vector_ull

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type

        __init__(vector_ull self, std::vector< unsigned long long >::size_type size, std::vector< unsigned long long >::value_type const & value) -> vector_ull

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type
        value: std::vector< unsigned long long >::value_type const &

        """
        _ncu_report.vector_ull_swiginit(self, _ncu_report.new_vector_ull(*args))

    def push_back(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""
        push_back(vector_ull self, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        x: std::vector< unsigned long long >::value_type const &

        """
        return _ncu_report.vector_ull_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        r"""front(vector_ull self) -> std::vector< unsigned long long >::value_type const &"""
        return _ncu_report.vector_ull_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        r"""back(vector_ull self) -> std::vector< unsigned long long >::value_type const &"""
        return _ncu_report.vector_ull_back(self)

    def assign(self, n: "std::vector< unsigned long long >::size_type", x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""
        assign(vector_ull self, std::vector< unsigned long long >::size_type n, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        n: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _ncu_report.vector_ull_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(vector_ull self, std::vector< unsigned long long >::size_type new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned long long >::size_type

        resize(vector_ull self, std::vector< unsigned long long >::size_type new_size, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        new_size: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _ncu_report.vector_ull_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(vector_ull self, std::vector< unsigned long long >::iterator pos, std::vector< unsigned long long >::value_type const & x) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator
        x: std::vector< unsigned long long >::value_type const &

        insert(vector_ull self, std::vector< unsigned long long >::iterator pos, std::vector< unsigned long long >::size_type n, std::vector< unsigned long long >::value_type const & x)

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator
        n: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _ncu_report.vector_ull_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long long >::size_type") -> "void":
        r"""
        reserve(vector_ull self, std::vector< unsigned long long >::size_type n)

        Parameters
        ----------
        n: std::vector< unsigned long long >::size_type

        """
        return _ncu_report.vector_ull_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        r"""capacity(vector_ull self) -> std::vector< unsigned long long >::size_type"""
        return _ncu_report.vector_ull_capacity(self)
    __swig_destroy__ = _ncu_report.delete_vector_ull

# Register vector_ull in _ncu_report:
_ncu_report.vector_ull_swigregister(vector_ull)




def load_report(file_name: "char const *", library_dir: "std::string const &") -> "NV::Rules::IContext *":
    r"""
    load_report(char const * file_name, std::string const & library_dir) -> IContext

    Parameters
    ----------
    file_name: char const *
    library_dir: std::string const &

    """
    return _ncu_report.load_report(file_name, library_dir)
RuleKind_DEFAULT = _ncu_report.RuleKind_DEFAULT

RuleKind_GUIDED = _ncu_report.RuleKind_GUIDED

class IMetric(object):
    r"""Proxy of C++ NV::Rules::IMetric class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ValueKind_UNKNOWN = _ncu_report.IMetric_ValueKind_UNKNOWN
    
    ValueKind_ANY = _ncu_report.IMetric_ValueKind_ANY
    
    ValueKind_STRING = _ncu_report.IMetric_ValueKind_STRING
    
    ValueKind_FLOAT = _ncu_report.IMetric_ValueKind_FLOAT
    
    ValueKind_DOUBLE = _ncu_report.IMetric_ValueKind_DOUBLE
    
    ValueKind_UINT32 = _ncu_report.IMetric_ValueKind_UINT32
    
    ValueKind_UINT64 = _ncu_report.IMetric_ValueKind_UINT64
    
    MetricType_OTHER = _ncu_report.IMetric_MetricType_OTHER
    
    MetricType_COUNTER = _ncu_report.IMetric_MetricType_COUNTER
    
    MetricType_RATIO = _ncu_report.IMetric_MetricType_RATIO
    
    MetricType_THROUGHPUT = _ncu_report.IMetric_MetricType_THROUGHPUT
    
    MetricSubtype_NONE = _ncu_report.IMetric_MetricSubtype_NONE
    
    MetricSubtype_PEAK_SUSTAINED = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED
    
    MetricSubtype_PEAK_SUSTAINED_ACTIVE = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_ACTIVE
    
    MetricSubtype_PEAK_SUSTAINED_ACTIVE_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_ACTIVE_PER_SECOND
    
    MetricSubtype_PEAK_SUSTAINED_ELAPSED = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_ELAPSED
    
    MetricSubtype_PEAK_SUSTAINED_ELAPSED_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_ELAPSED_PER_SECOND
    
    MetricSubtype_PEAK_SUSTAINED_FRAME = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_FRAME
    
    MetricSubtype_PEAK_SUSTAINED_FRAME_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_FRAME_PER_SECOND
    
    MetricSubtype_PEAK_SUSTAINED_REGION = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_REGION
    
    MetricSubtype_PEAK_SUSTAINED_REGION_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PEAK_SUSTAINED_REGION_PER_SECOND
    
    MetricSubtype_PER_CYCLE_ACTIVE = _ncu_report.IMetric_MetricSubtype_PER_CYCLE_ACTIVE
    
    MetricSubtype_PER_CYCLE_ELAPSED = _ncu_report.IMetric_MetricSubtype_PER_CYCLE_ELAPSED
    
    MetricSubtype_PER_CYCLE_IN_FRAME = _ncu_report.IMetric_MetricSubtype_PER_CYCLE_IN_FRAME
    
    MetricSubtype_PER_CYCLE_IN_REGION = _ncu_report.IMetric_MetricSubtype_PER_CYCLE_IN_REGION
    
    MetricSubtype_PER_SECOND = _ncu_report.IMetric_MetricSubtype_PER_SECOND
    
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_ACTIVE = _ncu_report.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_ACTIVE
    
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_ELAPSED = _ncu_report.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_ELAPSED
    
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_FRAME = _ncu_report.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_FRAME
    
    MetricSubtype_PCT_OF_PEAK_SUSTAINED_REGION = _ncu_report.IMetric_MetricSubtype_PCT_OF_PEAK_SUSTAINED_REGION
    
    MetricSubtype_MAX_RATE = _ncu_report.IMetric_MetricSubtype_MAX_RATE
    
    MetricSubtype_PCT = _ncu_report.IMetric_MetricSubtype_PCT
    
    MetricSubtype_RATIO = _ncu_report.IMetric_MetricSubtype_RATIO
    
    RollupOperation_NONE = _ncu_report.IMetric_RollupOperation_NONE
    
    RollupOperation_AVG = _ncu_report.IMetric_RollupOperation_AVG
    
    RollupOperation_MAX = _ncu_report.IMetric_RollupOperation_MAX
    
    RollupOperation_MIN = _ncu_report.IMetric_RollupOperation_MIN
    
    RollupOperation_SUM = _ncu_report.IMetric_RollupOperation_SUM
    
    __swig_destroy__ = _ncu_report.delete_IMetric

    def name(self) -> "char const *":
        r"""name(IMetric self) -> char const *"""
        return _ncu_report.IMetric_name(self)

    def metric_type(self) -> "NV::Rules::IMetric::MetricType":
        r"""metric_type(IMetric self) -> NV::Rules::IMetric::MetricType"""
        return _ncu_report.IMetric_metric_type(self)

    def metric_subtype(self) -> "NV::Rules::IMetric::MetricSubtype":
        r"""metric_subtype(IMetric self) -> NV::Rules::IMetric::MetricSubtype"""
        return _ncu_report.IMetric_metric_subtype(self)

    def rollup_operation(self) -> "NV::Rules::IMetric::RollupOperation":
        r"""rollup_operation(IMetric self) -> NV::Rules::IMetric::RollupOperation"""
        return _ncu_report.IMetric_rollup_operation(self)

    def unit(self) -> "NV::Rules::IMetric::Unit":
        r"""unit(IMetric self) -> NV::Rules::IMetric::Unit"""
        return _ncu_report.IMetric_unit(self)

    def description(self) -> "NV::Rules::IMetric::Description":
        r"""description(IMetric self) -> NV::Rules::IMetric::Description"""
        return _ncu_report.IMetric_description(self)

    def kind(self, *args) -> "NV::Rules::IMetric::ValueKind":
        r"""
        kind(IMetric self) -> NV::Rules::IMetric::ValueKind
        kind(IMetric self, size_t instance) -> NV::Rules::IMetric::ValueKind

        Parameters
        ----------
        instance: size_t

        """
        return _ncu_report.IMetric_kind(self, *args)

    def has_value(self, *args) -> "bool":
        r"""
        has_value(IMetric self) -> bool
        has_value(IMetric self, NV::Rules::IMetric::ValueKind value_kind) -> bool

        Parameters
        ----------
        value_kind: enum NV::Rules::IMetric::ValueKind

        """
        return _ncu_report.IMetric_has_value(self, *args)

    def as_double(self, *args) -> "double":
        r"""
        as_double(IMetric self) -> double
        as_double(IMetric self, size_t instance) -> double

        Parameters
        ----------
        instance: size_t

        """
        return _ncu_report.IMetric_as_double(self, *args)

    def as_uint64(self, *args) -> "uint64_t":
        r"""
        as_uint64(IMetric self) -> uint64_t
        as_uint64(IMetric self, size_t instance) -> uint64_t

        Parameters
        ----------
        instance: size_t

        """
        return _ncu_report.IMetric_as_uint64(self, *args)

    def as_string(self, *args) -> "char const *":
        r"""
        as_string(IMetric self) -> char const
        as_string(IMetric self, size_t instance) -> char const *

        Parameters
        ----------
        instance: size_t

        """
        return _ncu_report.IMetric_as_string(self, *args)

    def num_instances(self) -> "size_t":
        r"""num_instances(IMetric self) -> size_t"""
        return _ncu_report.IMetric_num_instances(self)

    def has_correlation_ids(self) -> "bool":
        r"""has_correlation_ids(IMetric self) -> bool"""
        return _ncu_report.IMetric_has_correlation_ids(self)

    def correlation_ids(self) -> "NV::Rules::IMetric *":
        r"""correlation_ids(IMetric self) -> IMetric"""
        return _ncu_report.IMetric_correlation_ids(self)

# Register IMetric in _ncu_report:
_ncu_report.IMetric_swigregister(IMetric)

class ISourceInfo(object):
    r"""Proxy of C++ NV::Rules::ISourceInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_ISourceInfo

    def file_name(self) -> "char const *":
        r"""file_name(ISourceInfo self) -> char const *"""
        return _ncu_report.ISourceInfo_file_name(self)

    def line(self) -> "uint32_t":
        r"""line(ISourceInfo self) -> uint32_t"""
        return _ncu_report.ISourceInfo_line(self)

# Register ISourceInfo in _ncu_report:
_ncu_report.ISourceInfo_swigregister(ISourceInfo)

class INvtxRange(object):
    r"""Proxy of C++ NV::Rules::INvtxRange class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    PayloadType_PAYLOAD_UNKNOWN = _ncu_report.INvtxRange_PayloadType_PAYLOAD_UNKNOWN
    
    PayloadType_PAYLOAD_UINT64 = _ncu_report.INvtxRange_PayloadType_PAYLOAD_UINT64
    
    PayloadType_PAYLOAD_INT64 = _ncu_report.INvtxRange_PayloadType_PAYLOAD_INT64
    
    PayloadType_PAYLOAD_DOUBLE = _ncu_report.INvtxRange_PayloadType_PAYLOAD_DOUBLE
    
    PayloadType_PAYLOAD_UINT32 = _ncu_report.INvtxRange_PayloadType_PAYLOAD_UINT32
    
    PayloadType_PAYLOAD_INT32 = _ncu_report.INvtxRange_PayloadType_PAYLOAD_INT32
    
    PayloadType_PAYLOAD_FLOAT = _ncu_report.INvtxRange_PayloadType_PAYLOAD_FLOAT
    
    PayloadType_PAYLOAD_JSON = _ncu_report.INvtxRange_PayloadType_PAYLOAD_JSON
    
    __swig_destroy__ = _ncu_report.delete_INvtxRange

    def name(self) -> "std::string":
        r"""name(INvtxRange self) -> std::string"""
        return _ncu_report.INvtxRange_name(self)

    def has_attributes(self) -> "bool":
        r"""has_attributes(INvtxRange self) -> bool"""
        return _ncu_report.INvtxRange_has_attributes(self)

    def category(self) -> "uint32_t":
        r"""category(INvtxRange self) -> uint32_t"""
        return _ncu_report.INvtxRange_category(self)

    def color(self) -> "uint32_t":
        r"""color(INvtxRange self) -> uint32_t"""
        return _ncu_report.INvtxRange_color(self)

    def payload_type(self) -> "NV::Rules::INvtxRange::PayloadType":
        r"""payload_type(INvtxRange self) -> NV::Rules::INvtxRange::PayloadType"""
        return _ncu_report.INvtxRange_payload_type(self)

    def payload_as_uint64(self) -> "uint64_t":
        r"""payload_as_uint64(INvtxRange self) -> uint64_t"""
        return _ncu_report.INvtxRange_payload_as_uint64(self)

    def payload_as_double(self) -> "double":
        r"""payload_as_double(INvtxRange self) -> double"""
        return _ncu_report.INvtxRange_payload_as_double(self)

    def payload_as_string(self) -> "std::string":
        r"""payload_as_string(INvtxRange self) -> std::string"""
        return _ncu_report.INvtxRange_payload_as_string(self)

    def message(self) -> "std::string":
        r"""message(INvtxRange self) -> std::string"""
        return _ncu_report.INvtxRange_message(self)

# Register INvtxRange in _ncu_report:
_ncu_report.INvtxRange_swigregister(INvtxRange)

class INvtxDomainInfo(object):
    r"""Proxy of C++ NV::Rules::INvtxDomainInfo class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_INvtxDomainInfo

    def name(self) -> "std::string":
        r"""name(INvtxDomainInfo self) -> std::string"""
        return _ncu_report.INvtxDomainInfo_name(self)

    def push_pop_ranges(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""push_pop_ranges(INvtxDomainInfo self) -> vector_string"""
        return _ncu_report.INvtxDomainInfo_push_pop_ranges(self)

    def push_pop_range(self, idx: "size_t") -> "NV::Rules::INvtxRange *":
        r"""
        push_pop_range(INvtxDomainInfo self, size_t idx) -> INvtxRange

        Parameters
        ----------
        idx: size_t

        """
        return _ncu_report.INvtxDomainInfo_push_pop_range(self, idx)

    def start_end_ranges(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""start_end_ranges(INvtxDomainInfo self) -> vector_string"""
        return _ncu_report.INvtxDomainInfo_start_end_ranges(self)

    def start_end_range(self, idx: "size_t") -> "NV::Rules::INvtxRange *":
        r"""
        start_end_range(INvtxDomainInfo self, size_t idx) -> INvtxRange

        Parameters
        ----------
        idx: size_t

        """
        return _ncu_report.INvtxDomainInfo_start_end_range(self, idx)

# Register INvtxDomainInfo in _ncu_report:
_ncu_report.INvtxDomainInfo_swigregister(INvtxDomainInfo)

class INvtxState(object):
    r"""Proxy of C++ NV::Rules::INvtxState class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_INvtxState

    def domains(self) -> "std::vector< unsigned long long,std::allocator< unsigned long long > >":
        r"""domains(INvtxState self) -> vector_ull"""
        return _ncu_report.INvtxState_domains(self)

    def domain_by_id(self, id: "unsigned long long") -> "NV::Rules::INvtxDomainInfo *":
        r"""
        domain_by_id(INvtxState self, unsigned long long id) -> INvtxDomainInfo

        Parameters
        ----------
        id: unsigned long long

        """
        return _ncu_report.INvtxState_domain_by_id(self, id)

# Register INvtxState in _ncu_report:
_ncu_report.INvtxState_swigregister(INvtxState)

class IAction(object):
    r"""Proxy of C++ NV::Rules::IAction class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    NameBase_FUNCTION = _ncu_report.IAction_NameBase_FUNCTION
    
    NameBase_DEMANGLED = _ncu_report.IAction_NameBase_DEMANGLED
    
    NameBase_MANGLED = _ncu_report.IAction_NameBase_MANGLED
    
    __swig_destroy__ = _ncu_report.delete_IAction

    def name(self, *args) -> "char const *":
        r"""
        name(IAction self, NV::Rules::IAction::NameBase base=FUNCTION) -> char const

        Parameters
        ----------
        base: enum NV::Rules::IAction::NameBase

        """
        return _ncu_report.IAction_name(self, *args)

    def metric_by_name(self, metric_name: "char const *") -> "NV::Rules::IMetric *":
        r"""
        metric_by_name(IAction self, char const * metric_name) -> IMetric

        Parameters
        ----------
        metric_name: char const *

        """
        return _ncu_report.IAction_metric_by_name(self, metric_name)

    def metric_names(self) -> "std::set< std::string,std::less< std::string >,std::allocator< std::string > >":
        r"""metric_names(IAction self) -> set_string"""
        return _ncu_report.IAction_metric_names(self)

    def add_integer_metric(self, value_name: "char const *", value_kind: "NV::Rules::IMetric::ValueKind", value: "uint64_t") -> "NV::Rules::IMetric *":
        r"""
        add_integer_metric(IAction self, char const * value_name, NV::Rules::IMetric::ValueKind value_kind, uint64_t value) -> IMetric

        Parameters
        ----------
        value_name: char const *
        value_kind: enum NV::Rules::IMetric::ValueKind
        value: uint64_t

        """
        return _ncu_report.IAction_add_integer_metric(self, value_name, value_kind, value)

    def add_double_metric(self, value_name: "char const *", value_kind: "NV::Rules::IMetric::ValueKind", value: "double") -> "NV::Rules::IMetric *":
        r"""
        add_double_metric(IAction self, char const * value_name, NV::Rules::IMetric::ValueKind value_kind, double value) -> IMetric

        Parameters
        ----------
        value_name: char const *
        value_kind: enum NV::Rules::IMetric::ValueKind
        value: double

        """
        return _ncu_report.IAction_add_double_metric(self, value_name, value_kind, value)

    def add_string_metric(self, value_name: "char const *", value_kind: "NV::Rules::IMetric::ValueKind", value: "char const *") -> "NV::Rules::IMetric *":
        r"""
        add_string_metric(IAction self, char const * value_name, NV::Rules::IMetric::ValueKind value_kind, char const * value) -> IMetric

        Parameters
        ----------
        value_name: char const *
        value_kind: enum NV::Rules::IMetric::ValueKind
        value: char const *

        """
        return _ncu_report.IAction_add_string_metric(self, value_name, value_kind, value)

    def add_metric(self, value_name: "char const *") -> "NV::Rules::IMutableMetric *":
        r"""
        add_metric(IAction self, char const * value_name) -> NV::Rules::IMutableMetric *

        Parameters
        ----------
        value_name: char const *

        """
        return _ncu_report.IAction_add_metric(self, value_name)

    def source_info(self, address: "uint64_t") -> "NV::Rules::ISourceInfo *":
        r"""
        source_info(IAction self, uint64_t address) -> ISourceInfo

        Parameters
        ----------
        address: uint64_t

        """
        return _ncu_report.IAction_source_info(self, address)

    def source_files(self) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""source_files(IAction self) -> map_string_string"""
        return _ncu_report.IAction_source_files(self)

    def sass_by_pc(self, address: "uint64_t") -> "std::string":
        r"""
        sass_by_pc(IAction self, uint64_t address) -> std::string

        Parameters
        ----------
        address: uint64_t

        """
        return _ncu_report.IAction_sass_by_pc(self, address)

    def nvtx_state(self) -> "NV::Rules::INvtxState *":
        r"""nvtx_state(IAction self) -> INvtxState"""
        return _ncu_report.IAction_nvtx_state(self)

    def ptx_by_pc(self, address: "uint64_t") -> "std::string":
        r"""
        ptx_by_pc(IAction self, uint64_t address) -> std::string

        Parameters
        ----------
        address: uint64_t

        """
        return _ncu_report.IAction_ptx_by_pc(self, address)

# Register IAction in _ncu_report:
_ncu_report.IAction_swigregister(IAction)

class IRange(object):
    r"""Proxy of C++ NV::Rules::IRange class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IRange

    def num_actions(self) -> "size_t":
        r"""num_actions(IRange self) -> size_t"""
        return _ncu_report.IRange_num_actions(self)

    def action_by_idx(self, idx: "size_t") -> "NV::Rules::IAction *":
        r"""
        action_by_idx(IRange self, size_t idx) -> IAction

        Parameters
        ----------
        idx: size_t

        """
        return _ncu_report.IRange_action_by_idx(self, idx)

    def actions_by_nvtx(self, includes: "vector_string", excludes: "vector_string") -> "std::set< unsigned long long,std::less< unsigned long long >,std::allocator< unsigned long long > >":
        r"""
        actions_by_nvtx(IRange self, vector_string includes, vector_string excludes) -> set_ull

        Parameters
        ----------
        includes: std::vector< std::string,std::allocator< std::string > > const &
        excludes: std::vector< std::string,std::allocator< std::string > > const &

        """
        return _ncu_report.IRange_actions_by_nvtx(self, includes, excludes)

# Register IRange in _ncu_report:
_ncu_report.IRange_swigregister(IRange)

class IFrontend(object):
    r"""Proxy of C++ NV::Rules::IFrontend class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MsgType_MSG_NONE = _ncu_report.IFrontend_MsgType_MSG_NONE
    
    MsgType_MSG_OK = _ncu_report.IFrontend_MsgType_MSG_OK
    
    MsgType_MSG_OPTIMIZATION = _ncu_report.IFrontend_MsgType_MSG_OPTIMIZATION
    
    MsgType_MSG_WARNING = _ncu_report.IFrontend_MsgType_MSG_WARNING
    
    MsgType_MSG_ERROR = _ncu_report.IFrontend_MsgType_MSG_ERROR
    
    MarkerKind_SASS = _ncu_report.IFrontend_MarkerKind_SASS
    
    MarkerKind_SOURCE = _ncu_report.IFrontend_MarkerKind_SOURCE
    
    Severity_SEVERITY_DEFAULT = _ncu_report.IFrontend_Severity_SEVERITY_DEFAULT
    
    Severity_SEVERITY_LOW = _ncu_report.IFrontend_Severity_SEVERITY_LOW
    
    Severity_SEVERITY_HIGH = _ncu_report.IFrontend_Severity_SEVERITY_HIGH
    
    SpeedupType_LOCAL = _ncu_report.IFrontend_SpeedupType_LOCAL
    
    SpeedupType_GLOBAL = _ncu_report.IFrontend_SpeedupType_GLOBAL
    
    __swig_destroy__ = _ncu_report.delete_IFrontend

    def message(self, *args) -> "int":
        r"""
        message(IFrontend self, char const * str, char const * name=None) -> int

        Parameters
        ----------
        str: char const *
        name: char const *

        message(IFrontend self, NV::Rules::IFrontend::MsgType type, char const * str, char const * name=None) -> int

        Parameters
        ----------
        type: enum NV::Rules::IFrontend::MsgType
        str: char const *
        name: char const *

        """
        return _ncu_report.IFrontend_message(self, *args)

    def speedup(self, message_id: "int", type: "NV::Rules::IFrontend::SpeedupType", estimated_speedup: "double") -> "bool":
        r"""
        speedup(IFrontend self, int message_id, NV::Rules::IFrontend::SpeedupType type, double estimated_speedup) -> bool

        Parameters
        ----------
        message_id: int
        type: enum NV::Rules::IFrontend::SpeedupType
        estimated_speedup: double

        """
        return _ncu_report.IFrontend_speedup(self, message_id, type, estimated_speedup)

    def focus_metric(self, message_id: "int", metric_name: "char const *", metric_value: "double", severity: "NV::Rules::IFrontend::Severity", info: "char const *") -> "bool":
        r"""
        focus_metric(IFrontend self, int message_id, char const * metric_name, double metric_value, NV::Rules::IFrontend::Severity severity, char const * info) -> bool

        Parameters
        ----------
        message_id: int
        metric_name: char const *
        metric_value: double
        severity: enum NV::Rules::IFrontend::Severity
        info: char const *

        """
        return _ncu_report.IFrontend_focus_metric(self, message_id, metric_name, metric_value, severity, info)

    def source_marker(self, *args) -> "void":
        r"""
        source_marker(IFrontend self, char const * str, uint64_t address_or_line, NV::Rules::IFrontend::MarkerKind kind, NV::Rules::IFrontend::MsgType type=MSG_NONE)

        Parameters
        ----------
        str: char const *
        address_or_line: uint64_t
        kind: enum NV::Rules::IFrontend::MarkerKind
        type: enum NV::Rules::IFrontend::MsgType

        source_marker(IFrontend self, char const * str, uint64_t address_or_line, NV::Rules::IFrontend::MarkerKind kind, char const * file_name, NV::Rules::IFrontend::MsgType type=MSG_NONE)

        Parameters
        ----------
        str: char const *
        address_or_line: uint64_t
        kind: enum NV::Rules::IFrontend::MarkerKind
        file_name: char const *
        type: enum NV::Rules::IFrontend::MsgType

        """
        return _ncu_report.IFrontend_source_marker(self, *args)

    def load_chart_from_file(self, filename: "char const *") -> "void":
        r"""
        load_chart_from_file(IFrontend self, char const * filename)

        Parameters
        ----------
        filename: char const *

        """
        return _ncu_report.IFrontend_load_chart_from_file(self, filename)

    def __init__(self):
        r"""
        __init__(IFrontend self) -> IFrontend

        Parameters
        ----------
        self: PyObject *

        """
        if self.__class__ == IFrontend:
            _self = None
        else:
            _self = self
        _ncu_report.IFrontend_swiginit(self, _ncu_report.new_IFrontend(_self, ))
    def __disown__(self):
        self.this.disown()
        _ncu_report.disown_IFrontend(self)
        return weakref.proxy(self)

# Register IFrontend in _ncu_report:
_ncu_report.IFrontend_swigregister(IFrontend)

class IBaseContext(object):
    r"""Proxy of C++ NV::Rules::IBaseContext class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IBaseContext

    def handle_exception(self, msg: "char const *") -> "bool":
        r"""
        handle_exception(IBaseContext self, char const * msg) -> bool

        Parameters
        ----------
        msg: char const *

        """
        return _ncu_report.IBaseContext_handle_exception(self, msg)

    def get_version(self) -> "std::string":
        r"""get_version(IBaseContext self) -> std::string"""
        return _ncu_report.IBaseContext_get_version(self)

# Register IBaseContext in _ncu_report:
_ncu_report.IBaseContext_swigregister(IBaseContext)

class IController(object):
    r"""Proxy of C++ NV::Rules::IController class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IController

    def propose_rule(self, rule: "char const *") -> "void":
        r"""
        propose_rule(IController self, char const * rule)

        Parameters
        ----------
        rule: char const *

        """
        return _ncu_report.IController_propose_rule(self, rule)

    def __init__(self):
        r"""
        __init__(IController self) -> IController

        Parameters
        ----------
        self: PyObject *

        """
        if self.__class__ == IController:
            _self = None
        else:
            _self = self
        _ncu_report.IController_swiginit(self, _ncu_report.new_IController(_self, ))
    def __disown__(self):
        self.this.disown()
        _ncu_report.disown_IController(self)
        return weakref.proxy(self)

# Register IController in _ncu_report:
_ncu_report.IController_swigregister(IController)

class IEvaluator(IBaseContext):
    r"""Proxy of C++ NV::Rules::IEvaluator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IEvaluator

    def require_metric(self, metric: "char const *") -> "void":
        r"""
        require_metric(IEvaluator self, char const * metric)

        Parameters
        ----------
        metric: char const *

        """
        return _ncu_report.IEvaluator_require_metric(self, metric)

    def require_rule(self, rule: "char const *") -> "void":
        r"""
        require_rule(IEvaluator self, char const * rule)

        Parameters
        ----------
        rule: char const *

        """
        return _ncu_report.IEvaluator_require_rule(self, rule)

    def __init__(self):
        r"""
        __init__(IEvaluator self) -> IEvaluator

        Parameters
        ----------
        self: PyObject *

        """
        if self.__class__ == IEvaluator:
            _self = None
        else:
            _self = self
        _ncu_report.IEvaluator_swiginit(self, _ncu_report.new_IEvaluator(_self, ))
    def __disown__(self):
        self.this.disown()
        _ncu_report.disown_IEvaluator(self)
        return weakref.proxy(self)

# Register IEvaluator in _ncu_report:
_ncu_report.IEvaluator_swigregister(IEvaluator)

class IContext(IBaseContext):
    r"""Proxy of C++ NV::Rules::IContext class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ncu_report.delete_IContext

    def controller(self) -> "NV::Rules::IController *":
        r"""controller(IContext self) -> IController"""
        return _ncu_report.IContext_controller(self)

    def frontend(self) -> "NV::Rules::IFrontend *":
        r"""frontend(IContext self) -> IFrontend"""
        return _ncu_report.IContext_frontend(self)

    def num_ranges(self) -> "size_t":
        r"""num_ranges(IContext self) -> size_t"""
        return _ncu_report.IContext_num_ranges(self)

    def range_by_idx(self, idx: "size_t") -> "NV::Rules::IRange *":
        r"""
        range_by_idx(IContext self, size_t idx) -> IRange

        Parameters
        ----------
        idx: size_t

        """
        return _ncu_report.IContext_range_by_idx(self, idx)

# Register IContext in _ncu_report:
_ncu_report.IContext_swigregister(IContext)

import platform
from pathlib import Path


def __get_library_dir_and_load(load_func):
    ncu_os_from_python = {
        'Linux': 'linux',
        'Windows': 'windows',
        'Darwin': 'osx',
    }

    ncu_arch_from_python = {
        'x86_64': 'x64',
        'AMD64': 'x64',
        'aarch64': 'a64'
    }

    def __get_library_dir():
# assume the 'nvperf_host' library is located at
# '../../host/<var>/' (for OSX) or
# '../../target/<var>/' (or all other OSes)
# relative to the 'ncu_report' module

        library_path_not_found_error = FileNotFoundError(
            "Could not deduce NVIDIA Nsight Compute library directory. "
            "Is 'ncu_report.py' located in 'extras/python' relative "
            "to your installation directory?"
        )

# get the directory in which the imported module 'ncu_report' resides
        module_dir = Path(__file__).parent

# check that '../../' relative to module_dir exists
        if len(module_dir.parents) < 2:
            raise library_path_not_found_error

        os = ncu_os_from_python[platform.system()]
        if os == 'osx':
            host_or_target_dir = module_dir.parents[1].joinpath("host")
        else:
            host_or_target_dir = module_dir.parents[1].joinpath("target")

        if not host_or_target_dir.is_dir():
            raise library_path_not_found_error

# Filter any directories starting with 'target' as NSYS places their target
# files for local activities in the host directory
        var_dirs = [sub_dir for sub_dir in host_or_target_dir.iterdir() \
                    if sub_dir.is_dir() and not sub_dir.stem.startswith("target")]

# assume there is one and only one '<var>/' directory for the current
# operating system and architecture 
        arch = ncu_arch_from_python[platform.machine()]
        for var_dir in var_dirs:
            var_name = var_dir.stem
            if (os in var_name) and (arch in var_name):
                library_dir = str(var_dir)
                break

        if not library_dir:
            raise FileNotFoundError("Could not find any build variant for your system.")

        return library_dir

    def __convert_Path_to_str(file_name):
        if isinstance(file_name, Path):
            file_name = str(file_name)
        return file_name

    def __raise_if_file_does_not_exist(file_name):
        if not Path(file_name).exists():
            raise FileNotFoundError(
                "Could not load report file: {} does not exist.".format(file_name)
            )

    def load_report(file_name):
        """Load an NVIDIA Nsight Compute report file into an IContext object.

        Args:
            file_name (Union[str, pathlib.Path]): The relative or absolute path
                to the `.ncu-rep` report file.

        Returns:
            :obj:`IContext`: An IContext object representing the loaded report file.

        Raises:
            FileNotFoundError: Either if `file_name` does not exist or if the
                NVIDIA Nsight Compute library directory cannot be found.

        """
        file_name = __convert_Path_to_str(file_name)
        __raise_if_file_does_not_exist(file_name)
        library_dir = __get_library_dir()
        return load_func(file_name=file_name, library_dir=library_dir)

    return load_report


load_report = __get_library_dir_and_load(load_report)

def ncu_report_add_method(cls, name):
    """This decorator allows us to add methods to already defined classes
    easily.

    For example, to add a method called `foo` to a class `Bar` you could use the
    following syntax:

       @ncu_report_add_method(Bar, 'foo')
       def name_is_not_important(self, param):
           do_something_with(self.baz, param)

    Note that the first parameter of the defined function will be treated like
    the `self` parameter when defining methods directly in classes.

    Also, the `name_is_not_important` function will still be usable with the
    first parameter being an object of the class you are adding the method to.
    """
    def decorator(func):
        setattr(cls, name, func)
        return func
    return decorator

@ncu_report_add_method(IContext, "__len__")
def IContext__len(ictx):
    """Get the number of IRange objects of this IContext.

    Returns:
        int: The number of IRange objects.

    """
    return ictx.num_ranges()


@ncu_report_add_method(IContext, "__getitem__")
def IContext__getitem(ictx, key):
    """Get one or more IRange objects by index or by slice.

    Args:
        key (int, slice): The index or slice to retrieve.

    Returns:
        An IRange object or a slice of IRange objects.

    Raises:
        TypeError: If `key` is not of type :obj:`int` or :obj:`slice`.
        IndexError: If `key` is out of range for the IContext.

    """
    _len = len(ictx)
    if isinstance(key, int):
        if key < -_len or key >= _len:
            raise IndexError("IContext index out of range")
        if key < 0:
            key += _len
        return ictx.range_by_idx(key)
    if isinstance(key, slice):
        return tuple(ictx[i] for i in range(*key.indices(_len)))
    raise TypeError(
        "IContext indices must be integers or slices, not {}".format(
            type(key).__name__
        )
    )


@ncu_report_add_method(IContext, "__iter__")
def IContext__iter(ictx):
    """Get an iterator over the IRange objects of this IContext.

    Returns:
        iterator: An iterator over the IRange objects.

    """
    return (ictx[i] for i in range(len(ictx)))

@ncu_report_add_method(IRange, "__len__")
def IRange__len(irange):
    """Get the number of IAction objects of this IRange.

    Returns:
        int: The number of IAction objects.

    """
    return irange.num_actions()


@ncu_report_add_method(IRange, "__getitem__")
def IRange__getitem(irange, key):
    """Get one or more IAction objects by index or by slice.

    Args:
        key (int, slice): The index or slice to retrieve.

    Returns:
        An IAction object or a slice of IAction objects.

    Raises:
        TypeError: If `key` is not of type :obj:`int` or :obj:`slice`.
        IndexError: If `key` is out of range for the IContext.

    """
    _len = len(irange)
    if isinstance(key, int):
        if key < -_len or key >= _len:
            raise IndexError("IRange index out of range")
        if key < 0:
            key += _len
        return irange.action_by_idx(key)
    if isinstance(key, slice):
        return tuple(irange[i] for i in range(*key.indices(_len)))
    raise TypeError(
        "IRange indices must be integers or slices, not {}".format(
            type(key).__name__
        )
    )


@ncu_report_add_method(IRange, "__iter__")
def IRange__iter(irange):
    """Get an iterator over the IAction objects of this IRange.

    Returns:
        iterator: An iterator over the IAction objects.

    """
    return (irange[i] for i in range(len(irange)))

@ncu_report_add_method(IAction, "__str__")
def IAction__str(iaction):
    """Get a human-readable representation of this IAction.

    Returns:
        str: The name of the kernel the IAction object represents.

    """
    return iaction.name()


@ncu_report_add_method(IAction, "__len__")
def IAction__len(iaction):
    """Get the number of IMetric objects of this IAction.

    Returns:
        int: The number of IMetric objects.

    """
    return len(iaction.metric_names())


@ncu_report_add_method(IAction, "__iter__")
def IAction__iter(iaction):
    """Get an iterator over the metric names of this IAction.

    Returns:
        iterator: An iterator over the metric names.

    """
    return iter(iaction.metric_names())


@ncu_report_add_method(IAction, "__getitem__")
def IAction__getitem(iaction, key):
    """Get an IMetric object contained in this IAction by its name.

    Args:
        key (str): The name of the IMetric object to retrieve.

    Returns:
        :obj:`IMetric`: An IMetric object.

    Raises:
        TypeError: If `key` is not of type :obj:`str`.
        KeyError: If `key` is not the name of any IMetric object.

    """
    if not isinstance(key, str):
        raise TypeError(
            "IAction metric keys must be strings, not {}".format(type(key).__name__)
        )

    metric = iaction.metric_by_name(key)

    if metric is None:
        raise KeyError("no metric named '{}'".format(key))

    return metric

IMetric_kind_to_value_func = {
    IMetric.ValueKind_ANY: lambda *args: None,
    IMetric.ValueKind_DOUBLE: IMetric.as_double,
    IMetric.ValueKind_FLOAT: IMetric.as_double,
    IMetric.ValueKind_STRING: IMetric.as_string,
    IMetric.ValueKind_UINT32: IMetric.as_uint64,
    IMetric.ValueKind_UINT64: IMetric.as_uint64,
    IMetric.ValueKind_UNKNOWN: lambda *args: None,
}


@ncu_report_add_method(IMetric, "__str__")
def IMetric__str(imetric):
    """Get a human-readable representation of this IMetric.

    Returns:
        str: The name of the IMetric.

    """
    return imetric.name()


@ncu_report_add_method(IMetric, "value")
def IMetric__value(imetric, idx=None):
    """Get the value of this IMetric.

    Args:
        idx (:obj:`int`, optional): The index of the correlation ids. Defaults to None.

    Returns:
        The value of this IMetric as str, int or float.

    """
    args = tuple() if idx is None else (idx,)
    return IMetric_kind_to_value_func[imetric.kind(*args)](imetric, *args)


def IMetric__metric_subtype_using_None(member_func):
    def IMetric__metric_subtype(imetric):
        """Get the subtype of this IMetric.

        Returns:
            int: The subtype of this IMetric, if applicable, None otherwise.

        """
        subtype = member_func(imetric)
        if subtype == imetric.MetricSubtype_NONE:
            return None
        else:
            return subtype
    return IMetric__metric_subtype

wrapped_metric_subtype = IMetric__metric_subtype_using_None(IMetric.metric_subtype)
setattr(IMetric, "metric_subtype", wrapped_metric_subtype)


def IMetric__rollup_operation_using_None(member_func):
    def IMetric__rollup_operation(imetric):
        """Get the rollup operation of this IMetric.

        Returns:
            int, None: The rollup operation of this IMetric, if applicable,
                None otherwise.

        """
        rollup_op = member_func(imetric)
        if rollup_op == imetric.RollupOperation_NONE:
            return None
        else:
            return rollup_op
    return IMetric__rollup_operation

wrapped_rollup_operation = IMetric__rollup_operation_using_None(IMetric.rollup_operation)
setattr(IMetric, "rollup_operation", wrapped_rollup_operation)

@ncu_report_add_method(INvtxState, "__len__")
def INvtxState__len(invtx_state):
    """Get the number of INvtxDomainInfo objects of this INvtxState.

    Returns:
        int: The number of INvtxDomainInfo objects.

    """
    return len(invtx_state.domains())


@ncu_report_add_method(INvtxState, "__iter__")
def INvtxState__iter(invtx_state):
    """Get an iterator over the INvtxDomainInfo objects of this INvtxState.

    Returns:
        iterator: An iterator over the INvtxDomainInfo objects.

    """
    return iter(invtx_state.domains())


@ncu_report_add_method(INvtxState, "__getitem__")
def INvtxState__getitem(invtx_state, key):
    """Get an INvtxDomainInfo object by ID.

    Args:
        key (int): The ID of the INvtxDomainInfo object.

    Returns:
        :obj:`INvtxDomainInfo`: An INvtxDomainInfo object.

    Raises:
        TypeError: If `key` is not of type :obj:`int`.
        KeyError: If `key` is not a valid ID.

    """
    if isinstance(key, int):
        if key not in invtx_state.domains():
            raise KeyError("INvtxState invalid ID")
        return invtx_state.domain_by_id(key)
    raise TypeError(
        "INvtxState IDs must be integers, not {}".format(
            type(key).__name__
        )
    )

@ncu_report_add_method(INvtxDomainInfo, "__str__")
def INvtxDomainInfo__str(invtx_domain):
    """Get a human-readable representation of this INvtxDomainInfo.

    Returns:
        str: The name of the INvtxDomainInfo.

    """
    return invtx_domain.name()



